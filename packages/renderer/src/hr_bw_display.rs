use std::io::{self, Write};

use crate::{
    chunk_iter::{Collector, ToChunks},
    traits::RenderTarget,
    types::Size,
};

const BLOCK_TABLE: [char; 4] = [' ', 'â–„', 'â–€', 'â–ˆ'];
const SEXTANT_TABLE: [char; 64] = [
    ' ', 'ðŸ¬ž', 'ðŸ¬', 'ðŸ¬­', 'ðŸ¬‡', 'ðŸ¬¦', 'ðŸ¬–', 'ðŸ¬µ', 'ðŸ¬ƒ', 'ðŸ¬¢', 'ðŸ¬“', 'ðŸ¬±', 'ðŸ¬‹', 'ðŸ¬©', 'ðŸ¬š', 'ðŸ¬¹', 'ðŸ¬', 'ðŸ¬ ', 'ðŸ¬‘',
    'ðŸ¬¯', 'ðŸ¬‰', 'â–', 'ðŸ¬˜', 'ðŸ¬·', 'ðŸ¬…', 'ðŸ¬¤', 'ðŸ¬”', 'ðŸ¬³', 'ðŸ¬', 'ðŸ¬«', 'ðŸ¬œ', 'ðŸ¬»', 'ðŸ¬€', 'ðŸ¬Ÿ', 'ðŸ¬', 'ðŸ¬®', 'ðŸ¬ˆ', 'ðŸ¬§',
    'ðŸ¬—', 'ðŸ¬¶', 'ðŸ¬„', 'ðŸ¬£', 'â–Œ', 'ðŸ¬²', 'ðŸ¬Œ', 'ðŸ¬ª', 'ðŸ¬›', 'ðŸ¬º', 'ðŸ¬‚', 'ðŸ¬¡', 'ðŸ¬’', 'ðŸ¬°', 'ðŸ¬Š', 'ðŸ¬¨', 'ðŸ¬™', 'ðŸ¬¸', 'ðŸ¬†',
    'ðŸ¬¥', 'ðŸ¬•', 'ðŸ¬´', 'ðŸ¬Ž', 'ðŸ¬¬', 'ðŸ¬', 'â–ˆ',
];
pub const DOTS_TABLE: [char; 256] = [
    'â €', 'â¢€', 'â¡€', 'â£€', 'â  ', 'â¢ ', 'â¡ ', 'â£ ', 'â „', 'â¢„', 'â¡„', 'â£„', 'â ¤', 'â¢¤', 'â¡¤', 'â£¤', 'â ', 'â¢', 'â¡',
    'â£', 'â °', 'â¢°', 'â¡°', 'â£°', 'â ”', 'â¢”', 'â¡”', 'â£”', 'â ´', 'â¢´', 'â¡´', 'â£´', 'â ‚', 'â¢‚', 'â¡‚', 'â£‚', 'â ¢', 'â¢¢',
    'â¡¢', 'â£¢', 'â †', 'â¢†', 'â¡†', 'â£†', 'â ¦', 'â¢¦', 'â¡¦', 'â£¦', 'â ’', 'â¢’', 'â¡’', 'â£’', 'â ²', 'â¢²', 'â¡²', 'â£²', 'â –',
    'â¢–', 'â¡–', 'â£–', 'â ¶', 'â¢¶', 'â¡¶', 'â£¶', 'â ˆ', 'â¢ˆ', 'â¡ˆ', 'â£ˆ', 'â ¨', 'â¢¨', 'â¡¨', 'â£¨', 'â Œ', 'â¢Œ', 'â¡Œ', 'â£Œ',
    'â ¬', 'â¢¬', 'â¡¬', 'â£¬', 'â ˜', 'â¢˜', 'â¡˜', 'â£˜', 'â ¸', 'â¢¸', 'â¡¸', 'â£¸', 'â œ', 'â¢œ', 'â¡œ', 'â£œ', 'â ¼', 'â¢¼', 'â¡¼',
    'â£¼', 'â Š', 'â¢Š', 'â¡Š', 'â£Š', 'â ª', 'â¢ª', 'â¡ª', 'â£ª', 'â Ž', 'â¢Ž', 'â¡Ž', 'â£Ž', 'â ®', 'â¢®', 'â¡®', 'â£®', 'â š', 'â¢š',
    'â¡š', 'â£š', 'â º', 'â¢º', 'â¡º', 'â£º', 'â ž', 'â¢ž', 'â¡ž', 'â£ž', 'â ¾', 'â¢¾', 'â¡¾', 'â£¾', 'â ', 'â¢', 'â¡', 'â£', 'â ¡',
    'â¢¡', 'â¡¡', 'â£¡', 'â …', 'â¢…', 'â¡…', 'â£…', 'â ¥', 'â¢¥', 'â¡¥', 'â£¥', 'â ‘', 'â¢‘', 'â¡‘', 'â£‘', 'â ±', 'â¢±', 'â¡±', 'â£±',
    'â •', 'â¢•', 'â¡•', 'â£•', 'â µ', 'â¢µ', 'â¡µ', 'â£µ', 'â ƒ', 'â¢ƒ', 'â¡ƒ', 'â£ƒ', 'â £', 'â¢£', 'â¡£', 'â££', 'â ‡', 'â¢‡', 'â¡‡',
    'â£‡', 'â §', 'â¢§', 'â¡§', 'â£§', 'â “', 'â¢“', 'â¡“', 'â£“', 'â ³', 'â¢³', 'â¡³', 'â£³', 'â —', 'â¢—', 'â¡—', 'â£—', 'â ·', 'â¢·',
    'â¡·', 'â£·', 'â ‰', 'â¢‰', 'â¡‰', 'â£‰', 'â ©', 'â¢©', 'â¡©', 'â£©', 'â ', 'â¢', 'â¡', 'â£', 'â ­', 'â¢­', 'â¡­', 'â£­', 'â ™',
    'â¢™', 'â¡™', 'â£™', 'â ¹', 'â¢¹', 'â¡¹', 'â£¹', 'â ', 'â¢', 'â¡', 'â£', 'â ½', 'â¢½', 'â¡½', 'â£½', 'â ‹', 'â¢‹', 'â¡‹', 'â£‹',
    'â «', 'â¢«', 'â¡«', 'â£«', 'â ', 'â¢', 'â¡', 'â£', 'â ¯', 'â¢¯', 'â¡¯', 'â£¯', 'â ›', 'â¢›', 'â¡›', 'â£›', 'â »', 'â¢»', 'â¡»',
    'â£»', 'â Ÿ', 'â¢Ÿ', 'â¡Ÿ', 'â£Ÿ', 'â ¿', 'â¢¿', 'â¡¿', 'â£¿',
];

pub enum Res {
    Low,
    High,
    Extra,
}

impl Res {
    fn to_size(&self) -> Size {
        match self {
            Self::High => Size { w: 2, h: 3 },
            Self::Low => Size { w: 1, h: 2 },
            Self::Extra => Size { w: 2, h: 4 },
        }
    }

    /// this is a fake render, not from Renderable trait
    fn render(&self, v: u8) -> char {
        match self {
            Self::Extra => DOTS_TABLE[v as usize],
            Self::High => SEXTANT_TABLE[v as usize],
            Self::Low => BLOCK_TABLE[v as usize],
        }
    }
}

impl Collector<bool> for u8 {
    fn new(_w: usize) -> Self {
        0
    }

    fn push(&mut self, v: bool) {
        *self = (*self << 1) | (v as u8);
    }

    fn empty(&mut self) {
        self.push(false)
    }
}

pub struct HighResBWScreen {
    w: usize,
    rw: usize,
    res: Res,
}

impl HighResBWScreen {
    pub fn new(w: usize, res: Res) -> Self {
        Self {
            w,
            rw: w.div_ceil(res.to_size().w),
            res,
        }
    }
}

impl RenderTarget<bool> for HighResBWScreen {
    type Error = io::Error;

    fn init(&self) -> Result<(), Self::Error> {
        print!("\x1B[?1049h");
        print!("\x1B[?25l");
        print!("\x1B[2J\x1B[H");
        io::stdout().flush()
    }

    fn exit(&self) -> Result<(), Self::Error> {
        print!("\x1B[?1049l");
        print!("\x1b[?25h");
        io::stdout().flush()
    }

    fn draw<I>(&mut self, items: I) -> Result<(), Self::Error>
    where
        I: Iterator<Item = bool>,
    {
        let size = self.res.to_size();

        let mut scaled = items
            .to_chunks::<u8>(self.w, size.w, size.h)
            .map(|x| self.res.render(x));

        loop {
            let line = scaled.by_ref().take(self.rw).collect::<String>();

            if line.is_empty() {
                break;
            }

            print!("\n\r{}", line);
        }

        io::stdout().flush()
    }
}
